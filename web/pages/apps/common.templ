package apps

import (
	"fmt"
	"time"
	
	"github.com/narvanalabs/control-plane/web/api"
	"github.com/narvanalabs/control-plane/web/components/badge"
)

// DeploymentStatusBadge renders a status badge for deployments
templ DeploymentStatusBadge(status string) {
	switch status {
		case "running":
			@badge.Badge(badge.Props{Variant: badge.VariantDefault, Class: "bg-green-500/10 text-green-500 border-green-500/20"}) { running }
		case "building":
			@badge.Badge(badge.Props{Variant: badge.VariantSecondary}) { building }
		case "pending":
			@badge.Badge(badge.Props{Variant: badge.VariantOutline}) { pending }
		case "failed":
			@badge.Badge(badge.Props{Variant: badge.VariantDestructive}) { failed }
		default:
			@badge.Badge(badge.Props{Variant: badge.VariantOutline}) { { status } }
	}
}

// EmptyState renders an empty state message
templ EmptyState(title string, description string) {
	<div class="flex flex-col items-center justify-center rounded-lg border border-dashed p-12">
		<h3 class="text-lg font-medium">{ title }</h3>
		<p class="text-muted-foreground text-center mt-1">
			{ description }
		</p>
	</div>
}

func intToString(i int) string {
	return fmt.Sprintf("%d", i)
}

func formatTime(t time.Time) string {
	diff := time.Since(t)
	switch {
	case diff < time.Minute:
		return "just now"
	case diff < time.Hour:
		return fmt.Sprintf("%dm ago", int(diff.Minutes()))
	case diff < 24*time.Hour:
		return fmt.Sprintf("%dh ago", int(diff.Hours()))
	default:
		return t.Format("Jan 2, 2006")
	}
}

func getLogLevelClass(level string) string {
	switch level {
	case "info":
		return "text-blue-400"
	case "warning":
		return "text-yellow-400"
	case "error":
		return "text-red-400"
	case "debug":
		return "text-zinc-500"
	default:
		return "text-zinc-400"
	}
}

// getServicePort returns the port for a service with appropriate defaults.
// For databases, returns the standard port for that database type.
// For web services, defaults to 8080.
func getServicePort(svc api.Service) int {
	if svc.Port > 0 {
		return svc.Port
	}
	// Database-specific defaults
	if svc.SourceType == "database" && svc.Database != nil {
		switch svc.Database.Type {
		case "postgres", "postgresql":
			return 5432
		case "mysql", "mariadb":
			return 3306
		case "redis":
			return 6379
		case "mongodb", "mongo":
			return 27017
		case "sqlite":
			return 0 // SQLite doesn't use a port
		}
	}
	return 8080
}

// isDatabaseService returns true if the service is a database
func isDatabaseService(svc api.Service) bool {
	return svc.SourceType == "database" && svc.Database != nil
}

// getDependentServices returns a list of services that depend on the given service name
func getDependentServices(app api.App, serviceName string) []string {
	var dependents []string
	for _, svc := range app.Services {
		for _, dep := range svc.DependsOn {
			if dep == serviceName {
				dependents = append(dependents, svc.Name)
				break
			}
		}
	}
	return dependents
}

// getDatabaseURLPrefix returns the prefix of a database URL (protocol://user:)
// Used to display the URL with the password masked
func getDatabaseURLPrefix(svc api.Service) string {
	if svc.Database == nil {
		return "postgresql://" + svc.Name + ":"
	}
	user := svc.Name
	switch svc.Database.Type {
	case "mysql", "mariadb":
		return "mysql://" + user + ":"
	case "mongodb", "mongo":
		return "mongodb://" + user + ":"
	case "redis":
		return "redis://:"
	default:
		return "postgresql://" + user + ":"
	}
}

// getDatabaseURLSuffix returns the suffix of a database URL (@host:port/dbname)
// Used to display the URL with the password masked
func getDatabaseURLSuffix(svc api.Service, appID string) string {
	host := appID + "-" + svc.Name + ".narvana.local"
	port := getServicePort(svc)
	dbName := svc.Name
	
	if svc.Database != nil && svc.Database.Type == "redis" {
		return fmt.Sprintf("@%s:%d", host, port)
	}
	return fmt.Sprintf("@%s:%d/%s", host, port, dbName)
}
